diff --git a/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java b/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java
index c1080f82..1261a06a 100644
--- a/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java
+++ b/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java
@@ -17,7 +17,6 @@
 package org.apache.commons.collections4.keyvalue;
 
 import java.io.Serializable;
-import java.lang.reflect.Array;
 import java.util.Arrays;
 import java.util.Objects;
 
@@ -52,69 +51,8 @@ public class MultiKey<K> implements Serializable {
     /** Serialisation version */
     private static final long serialVersionUID = 4465448607415788805L;
 
-    @SuppressWarnings("unchecked")
-    private static <T> Class<? extends T> getClass(final T value) {
-        return (Class<? extends T>) (value == null ? Object.class : value.getClass());
-    }
-
-    private static <T> Class<? extends T> getComponentType(final T... values) {
-        @SuppressWarnings("unchecked")
-        final Class<? extends T> rootClass = (Class<? extends T>) Object.class;
-        if (values == null) {
-            return rootClass;
-        }
-        Class<? extends T> prevClass = values.length > 0 ? getClass(values[0]) : rootClass;
-        for (int i = 1; i < values.length; i++) {
-            final Class<? extends T> classI = getClass(values[i]);
-            if (prevClass != classI) {
-                return rootClass;
-            }
-            prevClass = classI;
-        }
-        return prevClass;
-    }
-
-    private static <T> T[] newArray(final T key1, final T key2) {
-        @SuppressWarnings("unchecked")
-        final T[] array = (T[]) Array.newInstance(getComponentType(key1, key2), 2);
-        array[0] = key1;
-        array[1] = key2;
-        return array;
-    }
-
-    private static <T> T[] newArray(final T key1, final T key2, final T key3) {
-        @SuppressWarnings("unchecked")
-        final T[] array = (T[]) Array.newInstance(getComponentType(key1, key2, key3), 3);
-        array[0] = key1;
-        array[1] = key2;
-        array[2] = key3;
-        return array;
-    }
-
-    private static <T> T[] newArray(final T key1, final T key2, final T key3, final T key4) {
-        @SuppressWarnings("unchecked")
-        final T[] array = (T[]) Array.newInstance(getComponentType(key1, key2, key3, key4), 4);
-        array[0] = key1;
-        array[1] = key2;
-        array[2] = key3;
-        array[3] = key4;
-        return array;
-    }
-
-    private static <T> T[] newArray(final T key1, final T key2, final T key3, final T key4, final T key5) {
-        @SuppressWarnings("unchecked")
-        final T[] array = (T[]) Array.newInstance(getComponentType(key1, key2, key3, key4, key5), 5);
-        array[0] = key1;
-        array[1] = key2;
-        array[2] = key3;
-        array[3] = key4;
-        array[4] = key5;
-        return array;
-    }
-
     /** The individual keys */
     private final K[] keys;
-
     /** The cached hashCode */
     private transient int hashCode;
 
@@ -127,11 +65,11 @@ public class MultiKey<K> implements Serializable {
      * @param key1  the first key
      * @param key2  the second key
      */
+    @SuppressWarnings("unchecked")
     public MultiKey(final K key1, final K key2) {
-        this(newArray(key1, key2), false);
+        this((K[]) new Object[] { key1, key2 }, false);
     }
 
-
     /**
      * Constructor taking three keys.
      * <p>
@@ -142,8 +80,9 @@ public class MultiKey<K> implements Serializable {
      * @param key2  the second key
      * @param key3  the third key
      */
+    @SuppressWarnings("unchecked")
     public MultiKey(final K key1, final K key2, final K key3) {
-        this(newArray(key1, key2, key3), false);
+        this((K[]) new Object[] {key1, key2, key3}, false);
     }
 
     /**
@@ -157,8 +96,9 @@ public class MultiKey<K> implements Serializable {
      * @param key3  the third key
      * @param key4  the fourth key
      */
+    @SuppressWarnings("unchecked")
     public MultiKey(final K key1, final K key2, final K key3, final K key4) {
-        this(newArray(key1, key2, key3, key4), false);
+        this((K[]) new Object[] {key1, key2, key3, key4}, false);
     }
 
     /**
@@ -173,8 +113,9 @@ public class MultiKey<K> implements Serializable {
      * @param key4  the fourth key
      * @param key5  the fifth key
      */
+    @SuppressWarnings("unchecked")
     public MultiKey(final K key1, final K key2, final K key3, final K key4, final K key5) {
-        this(newArray(key1, key2, key3, key4, key5), false);
+        this((K[]) new Object[] {key1, key2, key3, key4, key5}, false);
     }
 
     /**
@@ -219,45 +160,26 @@ public class MultiKey<K> implements Serializable {
     public MultiKey(final K[] keys, final boolean makeClone) {
         super();
         Objects.requireNonNull(keys, "keys");
-        this.keys = makeClone ? keys.clone() : keys;
-        calculateHashCode(keys);
-    }
-
-    /**
-     * Calculate the hash code of the instance using the provided keys.
-     * @param keys the keys to calculate the hash code for
-     */
-    private void calculateHashCode(final Object[] keys)
-    {
-        int total = 0;
-        for (final Object key : keys) {
-            if (key != null) {
-                total ^= key.hashCode();
-            }
+        if (makeClone) {
+            this.keys = keys.clone();
+        } else {
+            this.keys = keys;
         }
-        hashCode = total;
+
+        calculateHashCode(keys);
     }
 
     //-----------------------------------------------------------------------
     /**
-     * Compares this object to another.
+     * Gets a clone of the array of keys.
      * <p>
-     * To be equal, the other object must be a {@code MultiKey} with the
-     * same number of keys which are also equal.
+     * The keys should be immutable
+     * If they are not then they must not be changed.
      *
-     * @param other  the other object to compare to
-     * @return true if equal
+     * @return the individual keys
      */
-    @Override
-    public boolean equals(final Object other) {
-        if (other == this) {
-            return true;
-        }
-        if (other instanceof MultiKey) {
-            final MultiKey<?> otherMulti = (MultiKey<?>) other;
-            return Arrays.equals(keys, otherMulti.keys);
-        }
-        return false;
+    public K[] getKeys() {
+        return keys.clone();
     }
 
     /**
@@ -275,17 +197,36 @@ public class MultiKey<K> implements Serializable {
         return keys[index];
     }
 
+    /**
+     * Gets the size of the list of keys.
+     *
+     * @return the size of the list of keys
+     * @since 3.1
+     */
+    public int size() {
+        return keys.length;
+    }
+
     //-----------------------------------------------------------------------
     /**
-     * Gets a clone of the array of keys.
+     * Compares this object to another.
      * <p>
-     * The keys should be immutable
-     * If they are not then they must not be changed.
+     * To be equal, the other object must be a {@code MultiKey} with the
+     * same number of keys which are also equal.
      *
-     * @return the individual keys
+     * @param other  the other object to compare to
+     * @return true if equal
      */
-    public K[] getKeys() {
-        return keys.clone();
+    @Override
+    public boolean equals(final Object other) {
+        if (other == this) {
+            return true;
+        }
+        if (other instanceof MultiKey) {
+            final MultiKey<?> otherMulti = (MultiKey<?>) other;
+            return Arrays.equals(keys, otherMulti.keys);
+        }
+        return false;
     }
 
     /**
@@ -304,33 +245,38 @@ public class MultiKey<K> implements Serializable {
     }
 
     /**
-     * Recalculate the hash code after deserialization. The hash code of some
-     * keys might have change (hash codes based on the system hash code are
-     * only stable for the same process).
-     * @return the instance with recalculated hash code
+     * Gets a debugging string version of the key.
+     *
+     * @return a debugging string
      */
-    protected Object readResolve() {
-        calculateHashCode(keys);
-        return this;
+    @Override
+    public String toString() {
+        return "MultiKey" + Arrays.toString(keys);
     }
 
     /**
-     * Gets the size of the list of keys.
-     *
-     * @return the size of the list of keys
-     * @since 3.1
+     * Calculate the hash code of the instance using the provided keys.
+     * @param keys the keys to calculate the hash code for
      */
-    public int size() {
-        return keys.length;
+    private void calculateHashCode(final Object[] keys)
+    {
+        int total = 0;
+        for (final Object key : keys) {
+            if (key != null) {
+                total ^= key.hashCode();
+            }
+        }
+        hashCode = total;
     }
 
     /**
-     * Gets a debugging string version of the key.
-     *
-     * @return a debugging string
+     * Recalculate the hash code after deserialization. The hash code of some
+     * keys might have change (hash codes based on the system hash code are
+     * only stable for the same process).
+     * @return the instance with recalculated hash code
      */
-    @Override
-    public String toString() {
-        return "MultiKey" + Arrays.toString(keys);
+    protected Object readResolve() {
+        calculateHashCode(keys);
+        return this;
     }
 }
